# C mcmc
mcmc_c <- compileNimble(mcmc)
# run
tmp <- runMCMC(mcmc_c, niter = niter, nchains = nchains)
# return
out <- list(samples = tmp)
return(out)
}
init_function <- function(data){
list(
z = apply(data$Y, 1, function(x) ifelse(sum(x) == 0, 0, 1)),
alpha = rnorm(2),
beta = rnorm(1),
rho = runif(1, .1, 5),
sigma = abs(rnorm(1, 0, sd = 2))
)
}
detach("package:nimble", unload = TRUE)
suppressMessages(library(nimble))
fit <- fit_spom(
constants = list(
pocc = data$pocc,
pdet = data$pdet,
nsites = data$nsites,
nvisits = data$nvisits,
rho_upr = max(dist)/2
),
data = list(
Y = data$Y,
x = data$X[,2],
W = data$W,
dist = data$dist,
ones = rep(1, nrow(data$X))
),
inits = init_function(data),
niter = 5000,
nchains = 3
)
saveRDS(fit, "rds files/spom/spom_fit.rds")
# traceplots
par(mfrow = c(3, 2))
for(i in 1:ncol(fit$samples[[1]])){
plot(
1, type = "n",
ylim = range(sapply(fit$samples, function(x) range(x[,i]))),
xlim = c(1, nrow(fit$samples[[1]])),
ylab = "estimate",
xlab = "iteration",
main = colnames(fit$samples[[1]])[i]
)
for(chain in 1:length(fit$samples)){
lines(fit$samples[[chain]][,i], col = chain)
}
}
data <- readRDS("rds files/spom/spom_data.rds")
fit_spom <- function(constants, data, inits, niter = 5000, nchains = 3){
# code
code <- nimbleCode({
# regression coefficients
for(i in 1:(pocc-1)){
beta[i] ~ dnorm(0, sd = 2)
}
for(i in 1:pdet){
alpha[i] ~ dnorm(0, sd = 2)
}
# spatial parameters
mu0 ~ dnorm(0, sd = 2)
rho ~ dunif(.1, rho_upr)
sigma ~ T(dnorm(0, sd = 2), 0, Inf)
# spatial mean
covmat[1:nsites, 1:nsites] <- dexpcov(
dists = dist[1:nsites, 1:nsites],
rho = rho,
sigma = sigma
)
mu[1:nsites] <- mu0 * ones[1:nsites]
eta[1:nsites] ~ dmnorm(mu[1:nsites], cov = covmat[1:nsites, 1:nsites])
# likelihood
for(site in 1:nsites){
logit(psi[site]) <- beta[1] * x[site] + eta[site]
z[site] ~ dbern(psi[site])
for(visit in 1:nvisits){
logit(p[site, visit]) <- alpha[1] + alpha[2] * W[site, visit, 2]
Y[site, visit] ~ dbern(z[site] * p[site, visit])
}
}
})
# R model
model <- nimbleModel(code, constants, data, inits)
# C model
model_c <- compileNimble(model)
# R mcmc
monitors <- c("beta", "alpha", "sigma", "rho")
# model_conf <- configureMCMC(model, monitors = monitors)
# model_conf$removeSamplers("eta[1:400]")
# model_conf$addSampler("eta[1:400]", "RW_block", control = list(scale = 0.15))
mcmc <- buildMCMC(model_conf)
# C mcmc
mcmc_c <- compileNimble(mcmc)
# run
tmp <- runMCMC(mcmc_c, niter = niter, nchains = nchains)
# return
out <- list(samples = tmp)
return(out)
}
init_function <- function(data){
list(
z = apply(data$Y, 1, function(x) ifelse(sum(x) == 0, 0, 1)),
alpha = rnorm(2),
beta = rnorm(1),
rho = runif(1, .1, 5),
sigma = abs(rnorm(1, 0, sd = 2))
)
}
detach("package:nimble", unload = TRUE)
suppressMessages(library(nimble))
fit <- fit_spom(
constants = list(
pocc = data$pocc,
pdet = data$pdet,
nsites = data$nsites,
nvisits = data$nvisits,
rho_upr = max(dist)/2
),
data = list(
Y = data$Y,
x = data$X[,2],
W = data$W,
dist = data$dist,
ones = rep(1, nrow(data$X))
),
inits = init_function(data),
niter = 5000,
nchains = 3
)
saveRDS(fit, "rds files/spom/spom_fit.rds")
data <- readRDS("rds files/spom/spom_data.rds")
fit_spom <- function(constants, data, inits, niter = 5000, nchains = 3){
# code
code <- nimbleCode({
# regression coefficients
for(i in 1:(pocc-1)){
beta[i] ~ dnorm(0, sd = 2)
}
for(i in 1:pdet){
alpha[i] ~ dnorm(0, sd = 2)
}
# spatial parameters
mu0 ~ dnorm(0, sd = 2)
rho ~ dunif(.1, rho_upr)
sigma ~ T(dnorm(0, sd = 2), 0, Inf)
# spatial mean
covmat[1:nsites, 1:nsites] <- dexpcov(
dists = dist[1:nsites, 1:nsites],
rho = rho,
sigma = sigma
)
mu[1:nsites] <- mu0 * ones[1:nsites]
eta[1:nsites] ~ dmnorm(mu[1:nsites], cov = covmat[1:nsites, 1:nsites])
# likelihood
for(site in 1:nsites){
logit(psi[site]) <- beta[1] * x[site] + eta[site]
z[site] ~ dbern(psi[site])
for(visit in 1:nvisits){
logit(p[site, visit]) <- alpha[1] + alpha[2] * W[site, visit, 2]
Y[site, visit] ~ dbern(z[site] * p[site, visit])
}
}
})
# R model
model <- nimbleModel(code, constants, data, inits)
# C model
model_c <- compileNimble(model)
# R mcmc
monitors <- c("beta", "alpha", "sigma", "rho")
model_conf <- configureMCMC(model, monitors = monitors)
# model_conf$removeSamplers("eta[1:400]")
# model_conf$addSampler("eta[1:400]", "RW_block", control = list(scale = 0.15))
mcmc <- buildMCMC(model_conf)
# C mcmc
mcmc_c <- compileNimble(mcmc)
# run
tmp <- runMCMC(mcmc_c, niter = niter, nchains = nchains)
# return
out <- list(samples = tmp)
return(out)
}
init_function <- function(data){
list(
z = apply(data$Y, 1, function(x) ifelse(sum(x) == 0, 0, 1)),
alpha = rnorm(2),
beta = rnorm(1),
rho = runif(1, .1, 5),
sigma = abs(rnorm(1, 0, sd = 2))
)
}
detach("package:nimble", unload = TRUE)
suppressMessages(library(nimble))
fit <- fit_spom(
constants = list(
pocc = data$pocc,
pdet = data$pdet,
nsites = data$nsites,
nvisits = data$nvisits,
rho_upr = max(dist)/2
),
data = list(
Y = data$Y,
x = data$X[,2],
W = data$W,
dist = data$dist,
ones = rep(1, nrow(data$X))
),
inits = init_function(data),
niter = 5000,
nchains = 3
)
saveRDS(fit, "rds files/spom/spom_fit.rds")
# traceplots
par(mfrow = c(3, 2))
for(i in 1:ncol(fit$samples[[1]])){
plot(
1, type = "n",
ylim = range(sapply(fit$samples, function(x) range(x[,i]))),
xlim = c(1, nrow(fit$samples[[1]])),
ylab = "estimate",
xlab = "iteration",
main = colnames(fit$samples[[1]])[i]
)
for(chain in 1:length(fit$samples)){
lines(fit$samples[[chain]][,i], col = chain)
}
}
data <- readRDS("rds files/spom/spom_data.rds")
fit_spom <- function(constants, data, inits, niter = 5000, nchains = 3){
# code
code <- nimbleCode({
# regression coefficients
for(i in 1:(pocc-1)){
beta[i] ~ dnorm(0, sd = 2)
}
for(i in 1:pdet){
alpha[i] ~ dnorm(0, sd = 2)
}
# spatial parameters
mu0 ~ dnorm(0, sd = 2)
rho ~ dunif(.1, rho_upr)
sigma ~ T(dnorm(0, sd = 2), 0, Inf)
# spatial mean
covmat[1:nsites, 1:nsites] <- dexpcov(
dists = dist[1:nsites, 1:nsites],
rho = rho,
sigma = sigma
)
mu[1:nsites] <- mu0 * ones[1:nsites]
eta[1:nsites] ~ dmnorm(mu[1:nsites], cov = covmat[1:nsites, 1:nsites])
# likelihood
for(site in 1:nsites){
logit(psi[site]) <- beta[1] * x[site] + eta[site]
z[site] ~ dbern(psi[site])
for(visit in 1:nvisits){
logit(p[site, visit]) <- alpha[1] + alpha[2] * W[site, visit, 2]
Y[site, visit] ~ dbern(z[site] * p[site, visit])
}
}
})
# R model
model <- nimbleModel(code, constants, data, inits)
# C model
model_c <- compileNimble(model)
# R mcmc
monitors <- c("beta", "alpha", "sigma", "rho")
model_conf <- configureMCMC(model, monitors = monitors, autoBlock = TRUE)
# model_conf$removeSamplers("eta[1:400]")
# model_conf$addSampler("eta[1:400]", "RW_block", control = list(scale = 0.15))
mcmc <- buildMCMC(model_conf)
# C mcmc
mcmc_c <- compileNimble(mcmc)
# run
tmp <- runMCMC(mcmc_c, niter = niter, nchains = nchains)
# return
out <- list(samples = tmp)
return(out)
}
init_function <- function(data){
list(
z = apply(data$Y, 1, function(x) ifelse(sum(x) == 0, 0, 1)),
alpha = rnorm(2),
beta = rnorm(1),
rho = runif(1, .1, 5),
sigma = abs(rnorm(1, 0, sd = 2)),
mu0 = 0
)
}
detach("package:nimble", unload = TRUE)
suppressMessages(library(nimble))
fit <- fit_spom(
constants = list(
pocc = data$pocc,
pdet = data$pdet,
nsites = data$nsites,
nvisits = data$nvisits,
rho_upr = max(dist)/2
),
data = list(
Y = data$Y,
x = data$X[,2],
W = data$W,
dist = data$dist,
ones = rep(1, nrow(data$X))
),
inits = init_function(data),
niter = 5000,
nchains = 3
)
saveRDS(fit, "rds files/spom/spom_fit.rds")
acf(fit$samples[,"rho"])
fit$samples
acf(fit$samples[[1]][,"rho"])
data <- readRDS("rds files/spom/spom_data.rds")
fit_spom <- function(constants, data, inits, niter = 5000, nchains = 3){
# code
code <- nimbleCode({
# regression coefficients
for(i in 1:(pocc-1)){
beta[i] ~ dnorm(0, sd = 2)
}
for(i in 1:pdet){
alpha[i] ~ dnorm(0, sd = 2)
}
# spatial parameters
mu0 ~ dnorm(0, sd = 2)
rho ~ dunif(.1, rho_upr)
sigma ~ T(dnorm(0, sd = 2), 0, Inf)
# spatial mean
covmat[1:nsites, 1:nsites] <- dexpcov(
dists = dist[1:nsites, 1:nsites],
rho = rho,
sigma = sigma
)
mu[1:nsites] <- mu0 * ones[1:nsites]
eta[1:nsites] ~ dmnorm(mu[1:nsites], cov = covmat[1:nsites, 1:nsites])
# likelihood
for(site in 1:nsites){
logit(psi[site]) <- beta[1] * x[site] + eta[site]
z[site] ~ dbern(psi[site])
for(visit in 1:nvisits){
logit(p[site, visit]) <- alpha[1] + alpha[2] * W[site, visit, 2]
Y[site, visit] ~ dbern(z[site] * p[site, visit])
}
}
})
# R model
model <- nimbleModel(code, constants, data, inits)
# C model
model_c <- compileNimble(model)
# R mcmc
monitors <- c("beta", "alpha", "sigma", "rho")
model_conf <- configureMCMC(model, monitors = monitors)
# customize MCMC
model_conf$removeSamplers("rho", "sigma")
model_conf$addSampler(
target = c("rho", "sigma"),
type = "RW_block",
control = list(
adaptInterval = 100
)
)
mcmc <- buildMCMC(model_conf)
# C mcmc
mcmc_c <- compileNimble(mcmc)
# run
tmp <- runMCMC(mcmc_c, niter = niter, nchains = nchains)
# return
out <- list(samples = tmp)
return(out)
}
init_function <- function(data){
list(
z = apply(data$Y, 1, function(x) ifelse(sum(x) == 0, 0, 1)),
alpha = rnorm(2),
beta = rnorm(1),
rho = runif(1, .1, 5),
sigma = abs(rnorm(1, 0, sd = 2)),
mu0 = 0
)
}
detach("package:nimble", unload = TRUE)
suppressMessages(library(nimble))
fit <- fit_spom(
constants = list(
pocc = data$pocc,
pdet = data$pdet,
nsites = data$nsites,
nvisits = data$nvisits,
rho_upr = max(dist)/2
),
data = list(
Y = data$Y,
x = data$X[,2],
W = data$W,
dist = data$dist,
ones = rep(1, nrow(data$X))
),
inits = init_function(data),
niter = 5000,
nchains = 3
)
saveRDS(fit, "rds files/spom/spom_fit.rds")
data <- readRDS("rds files/spom/spom_data.rds")
fit_spom <- function(constants, data, inits, niter = 5000, nchains = 3){
# code
code <- nimbleCode({
# regression coefficients
for(i in 1:(pocc-1)){
beta[i] ~ dnorm(0, sd = 2)
}
for(i in 1:pdet){
alpha[i] ~ dnorm(0, sd = 2)
}
# spatial parameters
mu0 ~ dnorm(0, sd = 2)
rho ~ dunif(.1, rho_upr)
sigma ~ T(dnorm(0, sd = 2), 0, Inf)
# spatial mean
covmat[1:nsites, 1:nsites] <- dexpcov(
dists = dist[1:nsites, 1:nsites],
rho = rho,
sigma = sigma
)
mu[1:nsites] <- mu0 * ones[1:nsites]
eta[1:nsites] ~ dmnorm(mu[1:nsites], cov = covmat[1:nsites, 1:nsites])
# likelihood
for(site in 1:nsites){
logit(psi[site]) <- beta[1] * x[site] + eta[site]
z[site] ~ dbern(psi[site])
for(visit in 1:nvisits){
logit(p[site, visit]) <- alpha[1] + alpha[2] * W[site, visit, 2]
Y[site, visit] ~ dbern(z[site] * p[site, visit])
}
}
})
# R model
model <- nimbleModel(code, constants, data, inits)
# C model
model_c <- compileNimble(model)
# R mcmc
monitors <- c("beta", "alpha", "sigma", "rho")
model_conf <- configureMCMC(model, monitors = monitors)
# customize MCMC
##use AFSS? https://r-nimble.org/better-block-sampling-in-mcmc-with-the-automated-factor-slice-sampler
model_conf$removeSamplers(c("rho", "sigma"))
model_conf$addSampler(
target = c("rho", "sigma"),
type = "AF_slice",
)
mcmc <- buildMCMC(model_conf)
# C mcmc
mcmc_c <- compileNimble(mcmc)
# run
tmp <- runMCMC(mcmc_c, niter = niter, nchains = nchains)
# return
out <- list(samples = tmp)
return(out)
}
init_function <- function(data){
list(
z = apply(data$Y, 1, function(x) ifelse(sum(x) == 0, 0, 1)),
alpha = rnorm(2),
beta = rnorm(1),
rho = runif(1, .1, 5),
sigma = abs(rnorm(1, 0, sd = 2)),
mu0 = 0
)
}
detach("package:nimble", unload = TRUE)
suppressMessages(library(nimble))
fit <- fit_spom(
constants = list(
pocc = data$pocc,
pdet = data$pdet,
nsites = data$nsites,
nvisits = data$nvisits,
rho_upr = max(dist)/2
),
data = list(
Y = data$Y,
x = data$X[,2],
W = data$W,
dist = data$dist,
ones = rep(1, nrow(data$X))
),
inits = init_function(data),
niter = 5000,
nchains = 3
)
saveRDS(fit, "rds files/spom/spom_fit.rds")
# traceplots
par(mfrow = c(3, 2))
for(i in 1:ncol(fit$samples[[1]])){
plot(
1, type = "n",
ylim = range(sapply(fit$samples, function(x) range(x[,i]))),
xlim = c(1, nrow(fit$samples[[1]])),
ylab = "estimate",
xlab = "iteration",
main = colnames(fit$samples[[1]])[i]
)
for(chain in 1:length(fit$samples)){
lines(fit$samples[[chain]][,i], col = chain)
}
}
